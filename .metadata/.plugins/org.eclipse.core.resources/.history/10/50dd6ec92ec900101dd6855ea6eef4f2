package com.aashdit.prod.heads.hims.ipms.service;


import com.aashdit.prod.heads.hims.umt.model.Role;
import com.aashdit.prod.heads.hims.umt.model.RoleRightLevelMaster;
import com.aashdit.prod.heads.hims.umt.model.User;
import com.aashdit.prod.heads.hims.umt.model.UserRoleMap;
import com.aashdit.prod.heads.hims.umt.repository.RoleRepository;
import com.aashdit.prod.heads.hims.umt.repository.RoleRightLevelMasterRepository;
import com.aashdit.prod.heads.hims.umt.repository.UserRepository;
import com.aashdit.prod.heads.hims.umt.repository.UserRoleMapRepository;
import com.aashdit.prod.heads.hims.umt.service.AccessService;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.MessageSource;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;

import com.aashdit.prod.heads.framework.core.ServiceOutcome;
import com.aashdit.prod.heads.framework.core.util.RandomString;
import com.aashdit.prod.heads.hims.ipms.dto.RegistrationFormDto;
import com.aashdit.prod.heads.hims.ipms.model.RegistrationForm;
import com.aashdit.prod.heads.hims.ipms.repository.*;
import com.aashdit.prod.heads.hims.ipms.utils.ApplicationConstants;

import lombok.extern.slf4j.Slf4j;

import javax.transaction.Transactional;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.util.Optional;

@Service
@Slf4j
public class RegistrationFormServiceImpl implements RegistrationFormService {

	@Autowired
	private RegistrationFormRepository registrationRepository;

	@Autowired
	private BCryptPasswordEncoder bCryptPasswordEncoder;

	@Autowired
	private RoleRepository roleRepository;

	@Autowired
	private UserRepository userRepository;

	@Autowired
	private UserRoleMapRepository userRoleMapRepository;

	@Autowired
	private RoleRightLevelMasterRepository roleRightLevelMasterRepository;

	@Autowired
	private AccessService accessService;

	@Autowired
	private MasterTypeRepository genderRepository;
	
	@Autowired
	private MessageSource messageSource;

	@Override
	@Transactional
	public ServiceOutcome<String> saveRegistrationDetails(RegistrationFormDto registrationFormDto) {
		ServiceOutcome<String> srvc = new ServiceOutcome<>();
		String message = "";

		try {
			User systemUser = userRepository.findByUserName(ApplicationConstants.SYSTEM_USER);
			if (systemUser == null) {
				srvc.setMessage("System user not found.");
				srvc.setOutcome(false);
				return srvc;
			}

			User userObj = userRepository.findByUserName(registrationFormDto.getContact());
			if (userObj != null) {
				srvc.setMessage("The mobile number you entered is already registered with our system. Please provide a different number.");
				srvc.setOutcome(false);
				return srvc;
			}

			RegistrationForm regForm;
			if (registrationFormDto.getRegistrationId() != null) {
				regForm = registrationRepository.findByRegistrationId(registrationFormDto.getRegistrationId());
				//regForm.setLastUpdatedBy(systemUser.getUserId());
				//regForm.setLastUpdatedOn(new Date());
				message = "Registration Updated Successfully";
			} else {
				RandomString rs = new RandomString(8);
				regForm = new RegistrationForm();
				regForm.setRegistrationCode(rs.nextString());
				//regForm.setCreatedBy(systemUser.getUserId());
				//regForm.setCreatedOn(new Date());
				regForm.setStatus("PENDING");
				message = "Registration Saved Successfully";
			}

			regForm.setFirstName(registrationFormDto.getFirstName());
			regForm.setLastName(registrationFormDto.getLastName());
    		regForm.setGenderId(genderRepository.findByTypeId(registrationFormDto.getGender()));
			SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
			Date date = sdf.parse(registrationFormDto.getDob());
			regForm.setDob(date);
			regForm.setContact(registrationFormDto.getContact());
			regForm.setEmail(registrationFormDto.getEmail());
			regForm.setIsActive(true);
			RegistrationForm savedReg = registrationRepository.save(regForm);

			User userDtls = new User();
			userDtls.setFirstName(regForm.getFirstName());
			userDtls.setLastName(regForm.getLastName() != null ? regForm.getLastName() : "");
			userDtls.setUserName(regForm.getContact());
			userDtls.setDateOfBirth(regForm.getDob());
			userDtls.setEmail(regForm.getEmail());
			userDtls.setPassword(bCryptPasswordEncoder.encode(registrationFormDto.getPassword()));
			userDtls.setActive(true);
//			userDtls.setIsEnabled(false);
			userDtls.setIsEnabled(true);
			userDtls.setIsLocked(false);
			userDtls.setIsLoggedIn(false);
			userDtls.setWrongLoginCount(0);
			userDtls.setAllowMultipleSession(true);
			userDtls.setMobile(String.valueOf(regForm.getContact()));
			userDtls.setCreatedOn(new Date());
			userDtls.setCreatedBy(systemUser.getUserId());
			userDtls.setUpdatedOn(new Date());
			userDtls.setUpdateBy(systemUser.getUserId());
			Role applicantRole = roleRepository.findByRoleCode(ApplicationConstants.ROLE_APPLICANT);
			userDtls.setPrimaryRole(applicantRole);
			userDtls = userRepository.save(userDtls);

			if (applicantRole != null) {
				UserRoleMap userRoleMap = new UserRoleMap();
				userRoleMap.setUserId(userDtls.getUserId());
				userRoleMap.setRoleId(applicantRole.getRoleId());
				userRoleMap.setIsActive(true);
				userRoleMap.setCreatedBy(systemUser.getUserId());
				userRoleMap.setUpdateBy(systemUser.getUserId());
				userRoleMap.setCreatedOn(new Date());
				userRoleMap.setUpdatedOn(new Date());
				userRoleMapRepository.save(userRoleMap);
			}

			RoleRightLevelMaster rrlm = roleRightLevelMasterRepository.findByLevelCode("PUBLIC");
			accessService.saveConfig(
					userDtls.getUserId(),
					applicantRole.getRoleId(),
					rrlm.getRoleRightLevelId(),
					savedReg.getRegistrationId()
			);

			srvc.setMessage(message);
			srvc.setOutcome(true);
		} catch (Exception e) {
			log.error("Exception occurred in saveRegistrationDetails method in RegistrationFormServiceImpl", e);
			srvc.setMessage("Error occurred while saving registration details.");
			srvc.setOutcome(false);
		}

		return srvc;
	}



	@Override
	public ServiceOutcome<RegistrationForm> getRegistrationDetailsObjectId(Long objectId) {
		ServiceOutcome<RegistrationForm> outcome = new ServiceOutcome<>();
		try {
			RegistrationForm regForm = registrationRepository.findByRegistrationId(objectId);
			if (regForm != null) {
				outcome.setData(regForm);
				outcome.setMessage("Registration details fetched successfully");
				outcome.setOutcome(true);
			} else {
				outcome.setMessage("No data found");
				outcome.setOutcome(false);
			}
		} catch (Exception e) {
			log.error("Error fetching registration by objectId", e);
			outcome.setMessage("Error occurred");
			outcome.setOutcome(false);
		}
		return outcome;
	}

	@Override
	public ServiceOutcome<RegistrationFormDto> getByregistrationId(Long registrationId) {
		ServiceOutcome<RegistrationFormDto> outcome = new ServiceOutcome<>();
		try {
			RegistrationFormDto regDto = new RegistrationFormDto();

			if(Optional.ofNullable(registrationId).isPresent()){
				regDto.setRegForm(registrationRepository.findByRegistrationId(registrationId));
			}
			outcome.setData(regDto);
			outcome.setOutcome(true);

		} catch (Exception e) {
			log.error("Error in getByregistrationId()", e);
		}
		return outcome;
	}

	@Override
	@Transactional
	public ServiceOutcome<RegistrationForm> processStatus(RegistrationFormDto dto) {
		ServiceOutcome<RegistrationForm> outcome = new ServiceOutcome<>();
		try {
			Optional<RegistrationForm> regOpt = registrationRepository.findById(dto.getRegistrationId());
			if (!regOpt.isPresent()) {
				outcome.setOutcome(false);
				outcome.setMessage("Registration record not found");
				return outcome;
			}

			RegistrationForm reg = regOpt.get();
			reg.setStatus(dto.getStatus());
			reg.setIsActive(!"REJECTED".equalsIgnoreCase(dto.getStatus()));
			registrationRepository.save(reg);

			User user = userRepository.findByUserName(reg.getContact());
			if (user != null) {
				switch (dto.getStatus().toUpperCase()) {
					case "APPROVED":
						user.setIsEnabled(true);
						break;
					case "REJECTED":
					case "PENDING":
					default:
						user.setIsEnabled(false);
						break;
				}
				user.setUpdatedOn(new Date());
				user.setUpdateBy(userRepository.findByUserName(ApplicationConstants.SYSTEM_USER).getUserId());
				userRepository.save(user);
			}
			outcome.setMessage("Registration " + dto.getStatus() + " successfully");
			outcome.setData(reg);
			outcome.setOutcome(true);

		} catch (Exception e) {
			log.error("Error processing registration status", e);
			outcome.setMessage("Something went wrong while processing status");
			outcome.setOutcome(false);
		}
		return outcome;
	}



	@Override
	public ServiceOutcome<RegistrationFormDto> getAllRegistration() {
		ServiceOutcome<RegistrationFormDto> svc = new ServiceOutcome<>();
		try {
			RegistrationFormDto regVo = new RegistrationFormDto();
			List<RegistrationForm> regList = registrationRepository.findAll();
			regVo.setRegFormList(regList);
			svc.setData(regVo);
			svc.setOutcome(true);
		} catch (Exception e) {
			log.error("Error occurred in getAllRegistration()", e);
			svc.setOutcome(false);
			svc.setMessage("An error occurred while fetching registration data.");
		}
		return svc;
	}
}
