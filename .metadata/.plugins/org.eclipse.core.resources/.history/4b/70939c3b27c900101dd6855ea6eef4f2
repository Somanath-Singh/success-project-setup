package com.aashdit.prod.heads.hims.ipms.controller;


import java.util.ArrayList;
import java.util.Base64;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import javax.persistence.EntityManager;
import javax.persistence.Query;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.servlet.http.HttpSession;

import org.jboss.logging.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.MessageSource;
import org.springframework.context.MessageSourceAware;
import org.springframework.context.i18n.LocaleContextHolder;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContext;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.servlet.mvc.support.RedirectAttributes;

import com.aashdit.prod.heads.framework.core.ServiceOutcome;
import com.aashdit.prod.heads.hims.ipms.model.ApplicationModuleMst;
import com.aashdit.prod.heads.hims.ipms.model.EntityAppModuleMap;
import com.aashdit.prod.heads.hims.ipms.utils.ApplicationConstants;
import com.aashdit.prod.heads.hims.ipms.utils.MainAppConstants;
import com.aashdit.prod.heads.hims.umt.dto.AuthRequest;
import com.aashdit.prod.heads.hims.umt.dto.CurrentUserVo;
import com.aashdit.prod.heads.hims.umt.dto.DynamicEntityDto;
import com.aashdit.prod.heads.hims.umt.model.LoggedInUser;
import com.aashdit.prod.heads.hims.umt.model.Menu;
import com.aashdit.prod.heads.hims.umt.model.Role;
import com.aashdit.prod.heads.hims.umt.model.RoleLevelMap;
import com.aashdit.prod.heads.hims.umt.model.RoleRightLevelMaster;
import com.aashdit.prod.heads.hims.umt.model.UmtNativeQuery;
import com.aashdit.prod.heads.hims.umt.model.User;
import com.aashdit.prod.heads.hims.umt.model.UserRoleMap;
import com.aashdit.prod.heads.hims.umt.model.UserRoleRightLevel;
import com.aashdit.prod.heads.hims.umt.repository.MenuRepository;
import com.aashdit.prod.heads.hims.umt.repository.UmtNativeQueryRepository;
import com.aashdit.prod.heads.hims.umt.repository.UserRoleRightLevelRepository;
import com.aashdit.prod.heads.hims.umt.service.EntityLevelService;
import com.aashdit.prod.heads.hims.umt.service.RoleService;
import com.aashdit.prod.heads.hims.umt.service.UserService;
import com.aashdit.prod.heads.hims.umt.utils.AesUtil;
import com.aashdit.prod.heads.hims.umt.utils.SecurityHelper;


@Controller
@RequestMapping("/overwrite")
public class CustomLoginController implements MessageSourceAware {

    private static final Logger logger = Logger.getLogger(CustomLoginController.class);
    private final EntityManager entityManager;
    private MessageSource messageSource;
    @Autowired
    private UserService userService;

    @Autowired
    private EntityLevelService entityLevelService;

    @Autowired
    private UserRoleRightLevelRepository userRoleLevelAccessRepository;


    @Value("${post.login.url}")
    private String POST_LOGIN_URL;
    @Value("${captcha.options}")
    private String CAPTCHA_OPTIONS;
    @Autowired
    private MenuRepository menuRepository;
    @Autowired
    private UmtNativeQueryRepository umtNativeQueryRepository;
    @Autowired
    private RoleService roleService;
    private List<Menu> m_menus;

    @Autowired
    public CustomLoginController(EntityManager entityManager) {
        this.entityManager = entityManager;
    }

    private static <T> Predicate<T> distinctByKey(java.util.function.Function<? super T, ?> keyExtractor) {
        Map<Object, Boolean> seen = new HashMap<>();
        return t -> {
            if (keyExtractor.apply(t) == null) {
                return false;
            }
            return seen.putIfAbsent(keyExtractor.apply(t), Boolean.TRUE) == null;
        };
    }

    public void setMessageSource(MessageSource messageSource) {
        this.messageSource = messageSource;
    }

    @PostMapping(path = {"/umt/login"}, name = "Login Processing POST")
    public String doLogin(HttpServletRequest request, HttpServletResponse response, AuthRequest authRequest, RedirectAttributes model) {
        String returnPath = "redirect:" + this.POST_LOGIN_URL;
        String realUsername = "";
        try {
        	String decryptedUserName =  new String(java.util.Base64.getDecoder().decode(authRequest.getUserName()));
            String psk1 = request.getParameter("_csrf");
            psk1 = psk1.substring(0, 16);
            AesUtil aesUtil = new AesUtil(128, 1000);
            
            if (decryptedUserName != null && decryptedUserName.split("::").length == 3) {
             realUsername = aesUtil.decrypt(decryptedUserName.split("::")[1], 
						            		 decryptedUserName.split("::")[0], psk1, 
						            		 decryptedUserName.split("::")[2]);
             authRequest.setUserName(realUsername);
            }
        	
            ServiceOutcome<User> svcOutcome = this.userService.findByUsername(authRequest.getUserName());
            if (!svcOutcome.getOutcome()) {
                handleError(model, svcOutcome.getMessage(), "System Issue");
                return "redirect:/login";
            }

            User user = svcOutcome.getData();
            if (user == null) {
                handleError(model, this.messageSource.getMessage("login.account.badcredentials", null, LocaleContextHolder.getLocale()), "Bad Credentials - No user found");
                checkDosAttack(request, authRequest.getUserName(), model);
                return "redirect:/login";
            }

            if (!user.getIsEnabled()) {
                handleError(model, this.messageSource.getMessage("login.account.disabled", null, LocaleContextHolder.getLocale()), "Account Disabled");
                return "redirect:/login";
            }

            if (user.getIsLocked()) {
                handleError(model, this.messageSource.getMessage("login.account.locked", null, LocaleContextHolder.getLocale()), "The account is locked.");
                return "redirect:/login";
            }

            if (user.getIsLoggedIn() && !user.getAllowMultipleSession()) {
                handleError(model, this.messageSource.getMessage("login.account.loggedin", null, LocaleContextHolder.getLocale()), "You are already logged-in.");
                return "redirect:/login";
            }

            if (!verifyCaptcha(request, authRequest, model)) {
                return "redirect:/login";
            }

            if (!verifyPassword(request, authRequest, user, model)) {
                handleFailedLogin(user);
                return "redirect:/login";
            }

            setupNewSession(request, user, response);
            return returnPath;

        } catch (Exception ex) {
            handleError(model, ex.getMessage(), "System Issue");
            return "redirect:/login";
        }
    }


    @PostMapping(path="/umt/switchRole", name ="Switch Role")
    public String switchRole(RedirectAttributes model, @RequestParam Long roleId, @RequestParam(required = false) Long entityId, HttpServletRequest request, HttpServletResponse response)
    {
        String returnPath =   "redirect:" + POST_LOGIN_URL;
        try
        {
            User user = SecurityHelper.getCurrentUser();
            Role role = roleService.findByRoleId(roleId).getData();

            user.setPrimaryRole(role);
            ServiceOutcome<User> svcUser = userService.save(user);
            if (svcUser.getOutcome())
            {
                if(entityId != null) {
                    this.updateUserRoleLevelAccess(entityId);
                }
                authorizeUser(request, user, response);
            }
            else
            {
                model.addFlashAttribute("err_msg", "Could not switch role");
            }

        }
        catch(Exception ex)
        {
            model.addFlashAttribute("err_msg", ex.getMessage());
            logger.error(ex);
        }

        return returnPath ;
    }




    // otp-base login
    @GetMapping(path = {"/umt/login/send-otp"}, name = "Login Processing POST")
    @ResponseBody
    public ResponseEntity<?> sendOtpToUser(@RequestParam("userName") String userName) {
        try {
            ServiceOutcome<User> svcOutcome = this.userService.findByUsername(userName);
            if (svcOutcome == null || !svcOutcome.getOutcome()) {
                return new ResponseEntity<>(this.messageSource.getMessage("account.not.found", null, LocaleContextHolder.getLocale()), HttpStatus.BAD_REQUEST);
            }else {
                User user = svcOutcome.getData();
                
            }
            throw new Exception("User not found");
        } catch (Exception ex) {
            return new ResponseEntity<>(ex.getMessage(), HttpStatus.INTERNAL_SERVER_ERROR);
        }
    }





    private void checkDosAttack(HttpServletRequest request, String userName, RedirectAttributes model) {
        int loginAttempt = checkdDosAttack(request, userName, model, "");
        if (loginAttempt >= 5) {
            handleError(model, "You have exceeded the 5 failed login attempt. Please contact your system admin for correct username and password.", "Dos Attack");
        }
    }

    private void handleError(RedirectAttributes model, String message, String logMessage) {
        model.addFlashAttribute("err_msg", message);
        logger.debug(logMessage);
    }

    private boolean verifyCaptcha(HttpServletRequest request, AuthRequest authRequest, RedirectAttributes model) {
        String svrCaptcha = (String) request.getSession().getAttribute("CAPTCHA_CODE");
        boolean verifyCaptcha = !this.CAPTCHA_OPTIONS.toLowerCase().contains("i");

        if (verifyCaptcha && !svrCaptcha.equals(authRequest.getCaptcha())) {
            handleError(model, this.messageSource.getMessage("login.account.badcaptcha", null, LocaleContextHolder.getLocale()), "Captcha Mismatch");
            return false;
        }
        return true;
    }

    private boolean verifyPassword(HttpServletRequest request, AuthRequest authRequest, User user, RedirectAttributes model) {
        String decryptedPassword = decryptPassword(authRequest.getPassword(), request.getParameter("_csrf"));
        if (decryptedPassword == null) {
            handleError(model, this.messageSource.getMessage("login.account.incorrect", null, LocaleContextHolder.getLocale()), "Bad Credentials - Invalid password");
            return false;
        }

        BCryptPasswordEncoder passwordEncoder = new BCryptPasswordEncoder();
        if (!passwordEncoder.matches(decryptedPassword, user.getPassword())) {
            handleError(model, this.messageSource.getMessage("login.account.incorrect", null, LocaleContextHolder.getLocale()), "Bad Credentials - Invalid password");
            return false;
        }
        return true;
    }

    public String decryptPassword(String encryptedPassword, String psk) {
        try {
            String realPass = "";
            psk = psk.substring(0, 16);
            String decryptedPassword = new String(Base64.getDecoder().decode(encryptedPassword));
            AesUtil aesUtil = new AesUtil(128, 1000);
            if (decryptedPassword.split("::").length == 3) {
                realPass = aesUtil.decrypt(decryptedPassword.split("::")[1], decryptedPassword.split("::")[0], psk, decryptedPassword.split("::")[2]);
            }
            return realPass;
        } catch (Exception ex) {
            logger.error("Error decrypting password: " + ex.getMessage());
        }
        return null;
    }

    private void handleFailedLogin(User user) {
        user.setWrongLoginCount(user.getWrongLoginCount() == null ? 1 : user.getWrongLoginCount() + 1);
        if (user.getWrongLoginCount() >= 5) {
            user.setIsLocked(true);
            user.setIsLoggedIn(false);
        }
        this.userService.save(user);
    }

    private void setupNewSession(HttpServletRequest request, User user, HttpServletResponse response) {
        HttpSession currentSession = request.getSession();
        currentSession.invalidate();
        authorizeUser(request, user, response);
    }

   public void assetVendorLogin(HttpServletRequest request, HttpServletResponse httpServletResponse) {
        ServiceOutcome<User> data = userService.findByUsername(MainAppConstants.VENDOR_USER_NAME);
        if (data.getOutcome()) {
            User user = data.getData();
            getLoggedInUser(request, user, httpServletResponse);
        }
    }

    public void loginDirectByUserName(HttpServletRequest request, HttpServletResponse httpServletResponse, String userName) {
        ServiceOutcome<User> data = userService.findByUsername(userName);
        if (data.getOutcome()) {
            User user = data.getData();
            authorizeUser(request, user, httpServletResponse);
        }
    }

    private void authorizeUser(HttpServletRequest request, User user, HttpServletResponse httpServletResponse) {
        LoggedInUser userDetails = getLoggedInUser(request, user, httpServletResponse);

        loadActiveUserRoleLevel(request, userDetails);
        loadModulesBasedOnPrimaryRole(request, userDetails);

        List<CurrentUserVo.AllEntityIdsAndLevel> allEntityIdsAndLevel = userDetails.getCurrentUserVo().getAllEntityIdsAndLevel();
        boolean isAnyEntityInactivated = false;
        // check if any entity is inactivated then don't allow to login
        if (allEntityIdsAndLevel != null && !allEntityIdsAndLevel.isEmpty()) {
            for (CurrentUserVo.AllEntityIdsAndLevel entityIdsAndLevel : allEntityIdsAndLevel) {
                try {
                    Optional<UmtNativeQuery> byQueryCode = umtNativeQueryRepository.findByQueryCode(entityIdsAndLevel.getEntityLevel());
                    if (byQueryCode.isPresent()) {
                        UmtNativeQuery query = byQueryCode.get();
                        String sql = query.getQuery();
                        sql = sql.replace(":objectId", String.valueOf(entityIdsAndLevel.getEntityId()));
                        Query nativeQuery = entityManager.createNativeQuery(sql);
                        @SuppressWarnings("unchecked")
                        List<Object[]> resultList = nativeQuery.getResultList();
                        if (!resultList.isEmpty()) {
                            Object[] result = resultList.get(0);
                            if (result.length > 3) {
                                boolean inactivated = result[3] != null && result[3] instanceof Boolean && (Boolean) result[3];
                                if (!inactivated) {
                                    isAnyEntityInactivated = true;
                                    break;
                                }
                            }
                        }
                    }
                } catch (Exception e) {
                    logger.error("Error checking entity inactivated: " + e.getMessage());
                }
            }
        }

        if (isAnyEntityInactivated) {
            SecurityContextHolder.clearContext();
            request.getSession().invalidate();
            throw new RuntimeException("You or your upper entity is inactivated. Please contact your system admin.");
        }

        userService.createLoginHistory(user, request);
    }

    private LoggedInUser getLoggedInUser(HttpServletRequest request, User user, HttpServletResponse httpServletResponse) {
        List<UserRoleMap> userRoleMaps = userService.findUserRoleMapByUserId(user.getUserId());
        userRoleMaps = userRoleMaps.stream().filter(r -> r.getIsActive().booleanValue()).collect(Collectors.toList());
        Set<GrantedAuthority> grantedAuthorities = new HashSet<>();
        List<Role> lstRoles = new ArrayList<>();
        for (UserRoleMap urm : userRoleMaps) {
            Role role = this.roleService.findByRoleId(urm.getRoleId()).getData();
            grantedAuthorities.add(new SimpleGrantedAuthority(role.getRoleCode()));
            if (role.getIsActive()) lstRoles.add(role);
        }
        user.setRoles(lstRoles);
        LoggedInUser userDetails = new LoggedInUser(user.getUserName(), user.getPassword(), true, true, true, true, grantedAuthorities, user.getPrimaryRole(), user);
        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(userDetails, null, grantedAuthorities);
        SecurityContext sc = SecurityContextHolder.getContext();
        sc.setAuthentication(usernamePasswordAuthenticationToken);
        HttpSession session = request.getSession(true);
        session.setAttribute("SPRING_SECURITY_CONTEXT", sc);
        addSameSiteCookieAttribute(httpServletResponse);
        return userDetails;
    }

    public void loadModulesBasedOnPrimaryRole(HttpServletRequest request, LoggedInUser userDetails) {
        Long entityId = userDetails.getCurrentUserVo().getEntityId();
        String entityLevel = userDetails.getCurrentUserVo().getUserLevel();
        List<ApplicationModuleMst> entityModules = new ArrayList<>();
        if (entityId != null && entityLevel != null) {
            List<EntityAppModuleMap> entityMapList = entityAppModuleMapRepository.findAllByObjectIdAndObjectType(entityId, entityLevel);
            entityModules = entityMapList.stream().map(EntityAppModuleMap::getAppModuleId).collect(Collectors.toList());
        }
        if(userDetails.getPrimaryRole().getRoleCode().equalsIgnoreCase("ROLE_ADMIN")) {
            Optional<ApplicationModuleMst> module = applicationModuleMstRepository.findByModuleCode("CORE");
            if(module.isPresent() && !entityModules.contains(module.get())) {
                entityModules.add(module.get());
            }
        }

        // if entityModules is empty, then call recursively check for parent entity
        if (entityModules.isEmpty()){
            entityModules = this.getEntityModulesByParent(userDetails.getCurrentUserVo(), 0);
        }

        request.getSession().setAttribute("USER_MODULES", entityModules);

    }

    private List<ApplicationModuleMst> getEntityModulesByParent(CurrentUserVo currentUserVo, int index) {
        if(currentUserVo.getAllEntityIdsAndLevel().isEmpty()) {
            return new ArrayList<>();
        }
        if (index >= currentUserVo.getAllEntityIdsAndLevel().size()) {
            return new ArrayList<>();
        }
        CurrentUserVo.AllEntityIdsAndLevel entity = currentUserVo.getAllEntityIdsAndLevel().get(index);
        long entityId = entity.getEntityId();
        String entityLevel = entity.getEntityLevel();
        List<EntityAppModuleMap> entityMapList = entityAppModuleMapRepository.findAllByObjectIdAndObjectType(entityId, entityLevel);
        List<ApplicationModuleMst> entityModules = entityMapList.stream().map(EntityAppModuleMap::getAppModuleId).collect(Collectors.toList());
        if (entityModules.isEmpty() && index < currentUserVo.getAllEntityIdsAndLevel().size()) {
            return getEntityModulesByParent(currentUserVo, index + 1);
        }
        return entityModules;
    }

    public void updateUserRoleLevelAccess(Long entityId) {
        // get userDetails first from SecurityContextHolder
        LoggedInUser userDetails = (LoggedInUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();
        List<UserRoleRightLevel> userAccessLvl = this.findUserRoleLevelAccessByUserDetails(userDetails);
        // make every user access level current access level to false
        userAccessLvl.forEach(ual -> {
            ual.setIsCurrentlyActiveSession(false);
        });
        userRoleLevelAccessRepository.saveAll(userAccessLvl);
        // get the UserRoleRightLevel by entityId
        Optional<UserRoleRightLevel> userRoleRightLevel = userRoleLevelAccessRepository.findById(entityId);
        if (userRoleRightLevel.isPresent()) {
            UserRoleRightLevel levelAccess = userRoleRightLevel.get();
            levelAccess.setIsCurrentlyActiveSession(true);
            userRoleLevelAccessRepository.save(levelAccess);
        }
    }

    public List<UserRoleRightLevel> findUserRoleLevelAccessByUserDetails(LoggedInUser userDetails) {
        Long currentUserId = userDetails.getDbUser().getUserId();
        Long primaryRoleId = userDetails.getPrimaryRole().getRoleId();
        Optional<UserRoleMap> userRoleMap = userService.findUserRoleMapByUserIdAndRoleId(currentUserId, primaryRoleId);
        if (userRoleMap.isPresent()) {
            Long userRoleMapId = userRoleMap.get().getUserRoleId();
            return userService.findUserRoleLevelAccessByUserRoleMapId(userRoleMapId);
        }
        return new ArrayList<>();
    }

    public void loadActiveUserRoleLevel(HttpServletRequest request, LoggedInUser userDetails) {
        CurrentUserVo currentUserVo = new CurrentUserVo();
        Long primaryRoleId = userDetails.getPrimaryRole().getRoleId();
        Long currentUserId = userDetails.getDbUser().getUserId();
        Optional<UserRoleMap> userRoleMap = userService.findUserRoleMapByUserIdAndRoleId(currentUserId, primaryRoleId);
        if (userRoleMap.isPresent()) {
            Long userRoleMapId = userRoleMap.get().getUserRoleId();
            List<UserRoleRightLevel> userRoleLevelAccess = userService.findUserRoleLevelAccessByUserRoleMapId(userRoleMapId);
            boolean isCurrentSessionActive = userRoleLevelAccess.stream().anyMatch(UserRoleRightLevel::getIsCurrentlyActiveSession);
            request.getSession().setAttribute("IS_CURRENT_OBJ_SESSION_ACTIVE", isCurrentSessionActive);
            if (isCurrentSessionActive) {
                Optional<UserRoleRightLevel> entityObject = userRoleLevelAccess.stream().filter(UserRoleRightLevel::getIsCurrentlyActiveSession).findFirst();
                if (entityObject.isPresent()) {
                    UserRoleRightLevel levelAccess = entityObject.get();
                    DynamicEntityDto crtVo = dynamicEntityList(levelAccess, primaryRoleId);
                    if (crtVo.getEntityIds() != null) {
                        // crtVo.getEntityIds() -> ?:?##?##?
                        String[] entityData = crtVo.getEntityIds().split(":");
                        if (entityData.length > 1) {
                            String[] ids = entityData[1].split("##");
                            if(ids.length > 0) {
                                currentUserVo.setEntityId(Long.parseLong(ids[0]));
                                currentUserVo.setCurrentUserEntityIdAndUserLevel(Long.parseLong(ids[0]) + "##" + crtVo.getEntityType());
                                List<CurrentUserVo.AllEntityIdsAndLevel> allEntityIdsAndLevels = new ArrayList<>();
                                entityLevelService.getParentObjectIdsAndLevel(Long.parseLong(ids[0]), crtVo.getEntityType(), allEntityIdsAndLevels);
                                allEntityIdsAndLevels.add(0, new CurrentUserVo.AllEntityIdsAndLevel(Long.parseLong(ids[0]), crtVo.getEntityType(), ids[0] + "##" + crtVo.getEntityType()));
                                currentUserVo.setAllEntityIdsAndLevel(allEntityIdsAndLevels);
                            }
                        }
                        currentUserVo.setPrimaryRole(userDetails.getPrimaryRole());
                        currentUserVo.setEntityIdStr(crtVo.getEntityIds());
                        currentUserVo.setEntityName(crtVo.getEntityName());
                        currentUserVo.setUserLevel(crtVo.getEntityType());
                        currentUserVo.setRoleRightLvlId(crtVo.getRoleRightLvlId());
                    }
                }
            }
            List<DynamicEntityDto> dynamicEntities = userRoleLevelAccess.stream().map(userRoleLevelAccess1 -> dynamicEntityList(userRoleLevelAccess1, primaryRoleId)).collect(Collectors.toList());
            currentUserVo.setDynamicEntities(dynamicEntities);

            // get GB or Mun Name and Icon
            setGbOrMunNameAndIcon(currentUserVo);

        }
        userDetails.setCurrentUserVo(currentUserVo);
    }

    private void setGbOrMunNameAndIcon(CurrentUserVo currentUserVo) {
        try {
            List<CurrentUserVo.AllEntityIdsAndLevel> allEntityIdsAndLevel = currentUserVo.getAllEntityIdsAndLevel();
            String gbOrMunName = "";
            String icon = "";
            if (allEntityIdsAndLevel != null && !allEntityIdsAndLevel.isEmpty()) {
                for (CurrentUserVo.AllEntityIdsAndLevel entityIdsAndLevel : allEntityIdsAndLevel) {
                    if (gbOrMunName != null && !gbOrMunName.isEmpty() && icon != null && !icon.isEmpty()) {
                        break;
                    }
                    Long entityId = entityIdsAndLevel.getEntityId();
                    String entityLevel = entityIdsAndLevel.getEntityLevel();
                    if(entityLevel.equalsIgnoreCase(ApplicationConstants.MUNICIPALITY)){
                        Municipality municipality = municipalityService.getMunicipalityById(entityId);
                        if (municipality != null){
                            gbOrMunName = municipality.getMunicipalityName();
                            icon = municipality.getIcon();
                        }
                    } else if(entityLevel.equalsIgnoreCase(ApplicationConstants.GOVERNING_BODY)){
                        GoverningBody governingBody = governingBodyService.getGoverningBodyById(entityId);
                        if (governingBody != null){
                            gbOrMunName = governingBody.getGoverningBodyName();
                            icon = governingBody.getIcon();
                        }
                    }
                }
            }
            currentUserVo.setGbOrMunName(gbOrMunName);
            currentUserVo.setIcon(icon);
        }catch (Exception e) {
            logger.error("Error setting GB or Mun Name and Icon: " + e.getMessage());
        }
    }

    private DynamicEntityDto dynamicEntityList(UserRoleRightLevel levelAccess, Long primaryRoleId) {
        DynamicEntityDto dto = new DynamicEntityDto();
        Long objectId = levelAccess.getObjectId();
        String objectLevel = levelAccess.getObjectLevel();
        Long roleLevelId = levelAccess.getRoleLevelId();
        Optional<RoleLevelMap> roleLvlMap = roleService.findRoleLevelMapByRoleAndRoleLevelMapId(primaryRoleId, roleLevelId);
        if (roleLvlMap.isPresent()) {
            RoleLevelMap roleLevelMap = roleLvlMap.get();
            Long roleRightLevelId = roleLevelMap.getLevelId();
            ServiceOutcome<RoleRightLevelMaster> roleRightLevelMaster = roleService.getRoleRightLevelMasterById(roleRightLevelId);
            if (roleRightLevelMaster.getOutcome()) {
                RoleRightLevelMaster rightLevelMaster = roleRightLevelMaster.getData();
                dto.setRoleRightLvlId(rightLevelMaster.getRoleRightLevelId());
                Optional<UmtNativeQuery> queryOptional = umtNativeQueryRepository.findByQueryCode(objectLevel);
                if (queryOptional.isPresent()) {
                    UmtNativeQuery query = queryOptional.get();
                    String sql = query.getQuery();
                    // replace: objectId if exists with the actual object id
                    sql = sql.replace(":objectId", String.valueOf(objectId));
                    Query nativeQuery = entityManager.createNativeQuery(sql);
                    @SuppressWarnings("unchecked")
                    List<Object[]> resultList = nativeQuery.getResultList();
                    if (!resultList.isEmpty()) {
                        Object[] result = resultList.get(0);
                        String idStr = levelAccess.getUserRoleRightLevelId() + ":";
                        idStr += result[0] != null ? result[0] : "";
                        dto.setEntityIds(idStr);
                        dto.setEntityName(result[1] != null ? result[1].toString() : null);
                        dto.setEntityType(result[2] != null ? result[2].toString() : null);

                        // from now take all in List<String>
                        Map<String, String> furtherData = new ConcurrentHashMap<>();
                        // get the total size of a result then loop through it starting from 3
                        for (int i = 3; i < result.length; i++) {
                            String value = result[i] != null ? result[i].toString() : null;
                            // split the value by "##" to get key and value
                            if (value != null && value.contains("##")) {
                                String[] split = value.split("##");
                                if (split.length == 2) {
                                    furtherData.put(split[0], split[1]);
                                }
                            }
                        }
                        dto.setFurtherDetails(furtherData);
                    }
                }
            }
        }
        return dto;
    }


    public void loadMenus(HttpServletRequest request, LoggedInUser liu, String appCode) {
        if (appCode != null) {
            m_menus = menuRepository.findUIMenusByRoleAndCode(liu.getPrimaryRole().getRoleId(), appCode);
        } else {
            m_menus = menuRepository.findUIMenusByRole(liu.getPrimaryRole().getRoleId());
        }
        List<Menu> parents = m_menus.stream().filter(m -> m.getParent() == null).collect(Collectors.toList());
        //Sort by Display Order
        try {
            parents = parents.stream().sorted((a, b) -> (a.getDisplayOrder() - b.getDisplayOrder())).collect(Collectors.toList());
        } catch (Exception ex) {
            logger.error("ERROR SORTING MENU -> " + ex.getMessage());
        }

        List<Menu> finalList = new ArrayList<Menu>();

        parents.forEach(m -> {
            m.setChildren(null);
            List<Menu> children = getMenuChildren(m);
            m.setChildren(children);
            finalList.add(m);
        });

        request.getSession().setAttribute("USER_MENUS", finalList);

        /* END UI Menu Addition */

        unLockUser(request.getParameter("userName"));
    }

    private void unLockUser(String username) {
        ServiceOutcome<User> svcOutcome = this.userService.findByUsername(username);
        User user = svcOutcome.getData();
        if (user != null) {
            user.setWrongLoginCount(Integer.valueOf(0));
            user.setIsLocked(Boolean.valueOf(false));
            user.setIsLoggedIn(Boolean.valueOf(true));
            this.userService.save(user);
        }
    }

    private List<Menu> getMenuChildren(Menu parent) {
        List<Menu> children = this.m_menus.stream().filter(m -> (m.getParent() != null && m.getParent().getMenuId() == parent.getMenuId())).filter(m -> (m.getIsDisplay().booleanValue())).collect(Collectors.toList());
        try {
            if (children != null) {
                children = children.stream().sorted((a, b) -> a.getDisplayOrder().intValue() - b.getDisplayOrder().intValue()).collect(Collectors.toList());
                children.forEach(m -> {
                    m.setChildren(null);
                    List<Menu> children2 = getMenuChildren(m);
                    m.setChildren(children2);
                });
            }
        } catch (Exception ex) {
            logger.error("ERROR SORTNG CHILD MENU -> " + ex.getMessage());
        }
        return children;
    }

    private int checkdDosAttack(HttpServletRequest request, String username, RedirectAttributes attr, String password) {
        HttpSession session = request.getSession();
        int loginAttempt;
        if (session.getAttribute("loginCount") == null) {
            session.setAttribute("loginCount", 0);
            loginAttempt = 0;
        } else {
            loginAttempt = (Integer) session.getAttribute("loginCount");
        }

        // this is 3 attempt counting from 0,1,2
        if (loginAttempt >= 5) {
            long lastAccessedTime = session.getLastAccessedTime();
            Date date = new Date();
            long currentTime = date.getTime();
            long timeDiff = currentTime - lastAccessedTime;
            // 20 minutes in milliseconds
            if (timeDiff >= 600000) {
                // invalidate user session, so they can try again
                session.invalidate();
            } else {
                // Error message
                loginAttempt++;
                attr.addFlashAttribute("err_msg", "You have exceeded the 3 failed login attempt. Please contact your system admin for correct username and password.");
                // loginService.createNoUserLoginHistory(username, request);
            }

        } else {
            // userService.saveFailedLoginHistory(request, username,password);
            loginAttempt++;
            int allowLogin = 5 - loginAttempt;
            attr.addFlashAttribute("err_msg", "Login Attempt = " + loginAttempt + ". Invalid username or password. You have " + allowLogin + " attempts remaining. Please try again!");
            // loginService.createNoUserLoginHistory(username, request);
        }
        session.setAttribute("loginCount", loginAttempt);
        session.setAttribute("lastAccessTime", session.getLastAccessedTime());
        return loginAttempt;
    }

    private void addSameSiteCookieAttribute(HttpServletResponse response) {
        Collection<String> headers = response.getHeaders(HttpHeaders.SET_COOKIE);
        boolean firstHeader = true;
        for (String header : headers) { // there can be multiple Set-Cookie attributes
            if (firstHeader) {
                response.setHeader(HttpHeaders.SET_COOKIE, String.format("%s; %s", header, "SameSite=Strict"));
                firstHeader = false;
                continue;
            }
            response.addHeader(HttpHeaders.SET_COOKIE, String.format("%s; %s", header, "SameSite=Strict"));
        }
    }



}
