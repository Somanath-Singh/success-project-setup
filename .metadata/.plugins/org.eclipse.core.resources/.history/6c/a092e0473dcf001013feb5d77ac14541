package com.aashdit.construction.utils;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;

import javax.imageio.ImageIO;

import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.ss.usermodel.WorkbookFactory;
import org.apache.poi.xwpf.usermodel.XWPFDocument;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.multipart.MultipartFile;

import com.aashdit.common.utils.PdfDocumentDetectorImpl;
import com.aashdit.construction.dto.FileValidationResult;

public final class FileValidator {

    private static final Logger log = LoggerFactory.getLogger(FileValidator.class);

    private static final String PDF_EXTENSION = "pdf";
    private static final String PNG_EXTENSION = "png";
    private static final String JPG_EXTENSION = "jpg";
    private static final String JPEG_EXTENSION = "jpeg";
    private static final String XLSX_EXTENSION = "xlsx";
    private static final String CSV_EXTENSION  = "csv";
    private static final String DOCX_EXTENSION = "docx";

    private static final long MAX_FILE_SIZE_BYTES = 2 * 1024 * 1024; // 2MB
    private static final int  CSV_SNIFF_BYTES = 4096;

    private FileValidator() {}

    /**
     * Generic validation method with extension + magic number + deep validation.
     * NOTE: For checks that need mark/reset, we wrap the stream with BufferedInputStream.
     */
    private static FileValidationResult validateFile(
            MultipartFile file,
            String[] allowedExtensions,
            boolean checkPdf,
            boolean checkImage
    ) {
        if (file == null || file.isEmpty() || file.getOriginalFilename() == null) {
            return new FileValidationResult(true, "No file provided.");
        }

        final String originalFilename = file.getOriginalFilename().trim();
        final String extension = getLowercaseExtension(new File(originalFilename));

        // Extension validation
        boolean validExtension = false;
        for (String allowed : allowedExtensions) {
            if (allowed.equalsIgnoreCase(extension)) {
                validExtension = true;
                break;
            }
        }
        if (!validExtension) {
            log.warn("Invalid file extension: {}", originalFilename);
            return new FileValidationResult(true,
                    "Allowed file types: " + String.join(", ", allowedExtensions));
        }

        // Size validation
        if (file.getSize() > MAX_FILE_SIZE_BYTES) {
            log.warn("File size too large: {} bytes, allowed: {} bytes", file.getSize(), MAX_FILE_SIZE_BYTES);
            return new FileValidationResult(true, "File size must be less than 2MB.");
        }
        if (file.getSize() == 0) {
            log.warn("Zero-byte file rejected: {}", originalFilename);
            return new FileValidationResult(true, "Empty file is not allowed.");
        }

        // Magic number check (real content detection)
        try (InputStream raw = file.getInputStream();
             BufferedInputStream in = new BufferedInputStream(raw)) {

            if (checkPdf) {
                if (!isPdfMagic(in)) {
                    log.error("Magic number mismatch: {} is not a real PDF", originalFilename);
                    return new FileValidationResult(true, "Invalid file type. Expected PDF.");
                }
            }

            if (checkImage) {
                if (!isImageMagic(in)) {
                    log.error("Magic number mismatch: {} is not a real image", originalFilename);
                    return new FileValidationResult(true, "Invalid file type. Expected PNG/JPG.");
                }
            }
        } catch (Exception e) {
            log.error("Error checking magic number for '{}': {}", originalFilename, e.getMessage(), e);
            return new FileValidationResult(true, "Unable to verify file content.");
        }

        // Deep content validation
        if (checkPdf) {
            try (InputStream in = file.getInputStream()) {
                boolean fileSafe = (new PdfDocumentDetectorImpl()).isSafe(in);
                if (!fileSafe) {
                    log.error("Suspicious PDF detected: {}", originalFilename);
                    return new FileValidationResult(true, "Suspicious PDF detected. Unable to save data.");
                }
            } catch (Exception e) {
                log.error("Error validating PDF file '{}': {}", originalFilename, e.getMessage(), e);
                return new FileValidationResult(true, "Error occurred while validating the uploaded PDF.");
            }
        }

        if (checkImage) {
            try (InputStream in = file.getInputStream()) {
                if (ImageIO.read(in) == null) {
                    log.error("Invalid image content: {}", originalFilename);
                    return new FileValidationResult(true, "The uploaded file is not a valid image.");
                }
            } catch (Exception e) {
                log.error("Error reading image file '{}': {}", originalFilename, e.getMessage(), e);
                return new FileValidationResult(true, "Error occurred while validating the uploaded image.");
            }
        }

        // All checks passed
        log.info("File validated successfully: {}", originalFilename);
        return new FileValidationResult(false, "File is safe.");
    }

    private static boolean isPdfMagic(InputStream in) throws IOException {
        // PDF: %PDF (25 50 44 46)
        in.mark(4);
        byte[] header = new byte[4];
        int n = in.read(header);
        in.reset();
        return n == 4 && header[0] == 0x25 && header[1] == 0x50 && header[2] == 0x44 && header[3] == 0x46;
    }

    private static boolean isImageMagic(InputStream in) throws IOException {
        in.mark(16);
        byte[] header = new byte[8];
        int read = in.read(header);
        in.reset();

        if (read >= 8) {
            // PNG signature: 89 50 4E 47 0D 0A 1A 0A
            if ((header[0] & 0xFF) == 0x89 && header[1] == 0x50 && header[2] == 0x4E &&
                header[3] == 0x47 && header[4] == 0x0D && header[5] == 0x0A &&
                header[6] == 0x1A && header[7] == 0x0A) {
                return true;
            }
        }

        if (read >= 3) {
            // JPEG signature: FF D8 FF
            if ((header[0] & 0xFF) == 0xFF && (header[1] & 0xFF) == 0xD8 &&
                (header[2] & 0xFF) == 0xFF) {
                return true;
            }
        }

        return false;
    }

    private static String getLowercaseExtension(File f) {
        String ext = CommonMethodUtil.getFileExtension(f);
        return ext == null ? "" : ext.trim().toLowerCase();
    }

    /** Validate PDF only */
    public static FileValidationResult validatePdf(MultipartFile file) {
        return validateFile(file, new String[]{PDF_EXTENSION}, true, false);
    }

    /** Validate PNG/JPG only */
    public static FileValidationResult validateImage(MultipartFile file) {
        return validateFile(file, new String[]{PNG_EXTENSION, JPG_EXTENSION, JPEG_EXTENSION}, false, true);
    }

    /**
     * Validate Excel (.xlsx only).
     * Added: Magic header detection to block renamed PDFs/invalid content.
     */
    public static FileValidationResult validateExcel(MultipartFile file) {
        FileValidationResult basicCheck = validateFile(file, new String[]{XLSX_EXTENSION}, false, false);
        if (basicCheck.isError()) {
            return basicCheck;
        }

        final String name = file.getOriginalFilename();
        try (InputStream raw = file.getInputStream(); BufferedInputStream in = new BufferedInputStream(raw)) {
            // Check magic header
            in.mark(8);
            byte[] header = new byte[8];
            int read = in.read(header);
            in.reset();

            if (read >= 4 && header[0] == '%' && header[1] == 'P' && header[2] == 'D' && header[3] == 'F') {
                log.error("File '{}' is actually a PDF, not Excel", name);
                return new FileValidationResult(true, "The uploaded file is a PDF, not an Excel document.");
            }

            if (!(header[0] == 'P' && header[1] == 'K')) {
                log.error("File '{}' is not a valid XLSX (missing PK ZIP signature)", name);
                return new FileValidationResult(true, "File extension is XLSX but content is invalid.");
            }
        } catch (Exception e) {
            log.error("Error checking magic header for Excel '{}': {}", name, e.getMessage());
            return new FileValidationResult(true, "Unable to verify Excel file type.");
        }

        // Structural validation
        try (InputStream in = file.getInputStream(); Workbook wb = WorkbookFactory.create(in)) {
            if (wb.getNumberOfSheets() <= 0) {
                log.error("XLSX has no sheets: {}", name);
                return new FileValidationResult(true, "The Excel file has no sheets and cannot be uploaded.");
            }
        } catch (Exception e) {
            log.error("Invalid Excel (.xlsx) file '{}': {}", name, e.getMessage(), e);
            return new FileValidationResult(true, "The uploaded file is not a valid .xlsx workbook.");
        }

        log.info("Excel (.xlsx) validated successfully: {}", name);
        return new FileValidationResult(false, "File is safe.");
    }

    /**
     * Validate CSV (.csv).
     * Heuristics: small text sniff, no NUL bytes, has delimiter (comma/semicolon) and a newline.
     */
    public static FileValidationResult validateCsv(MultipartFile file) {
        FileValidationResult basicCheck = validateFile(file, new String[]{CSV_EXTENSION}, false, false);
        if (basicCheck.isError()) {
            return basicCheck;
        }

        final String name = file.getOriginalFilename();
        if (file.getSize() < 2) {
            return new FileValidationResult(true, "CSV seems empty or too small.");
        }

        try (InputStream in = file.getInputStream()) {
            byte[] buf = new byte[(int) Math.min(CSV_SNIFF_BYTES, file.getSize())];
            int read = in.read(buf);
            if (read <= 0) {
                return new FileValidationResult(true, "Unable to read CSV content.");
            }

            // Quick binary check: reject if NUL bytes present
            for (int i = 0; i < read; i++) {
                if (buf[i] == 0) {
                    log.error("CSV appears binary (NUL byte found): {}", name);
                    return new FileValidationResult(true, "The uploaded file is not a valid CSV (binary content detected).");
                }
            }

            String head = new String(buf, 0, read, StandardCharsets.UTF_8);
            boolean hasDelimiter = head.contains(",") || head.contains(";");
            boolean hasNewline   = head.contains("\n") || head.contains("\r");

            if (!hasDelimiter || !hasNewline) {
                log.error("Invalid CSV structure (delimiter/newline missing): {}", name);
                return new FileValidationResult(true, "The uploaded file does not appear to be a valid CSV.");
            }
        } catch (Exception e) {
            log.error("Error validating CSV '{}': {}", name, e.getMessage());
            return new FileValidationResult(true, "Error occurred while validating the uploaded CSV.");
        }

        log.info("CSV validated successfully: {}", name);
        return new FileValidationResult(false, "File is safe.");
    }

    /**
     * Validate Word (.docx) files only.
     */
    public static FileValidationResult validateWordDocx(MultipartFile file) {
        FileValidationResult basicCheck = validateFile(file, new String[]{DOCX_EXTENSION}, false, false);
        if (basicCheck.isError()) {
            return basicCheck;
        }

        final String filename = file.getOriginalFilename();

        try (InputStream in = file.getInputStream(); XWPFDocument docx = new XWPFDocument(in)) {
            boolean empty = docx.getParagraphs().isEmpty() && docx.getTables().isEmpty();
            if (empty) {
                log.error("DOCX is empty: {}", filename);
                return new FileValidationResult(true, "The Word file is empty and cannot be uploaded.");
            }
        } catch (Exception e) {
            log.error("Invalid DOCX file '{}': {}", filename, e.getMessage());
            return new FileValidationResult(true, "The uploaded file is not a valid DOCX document.");
        }

        log.info("Word DOCX validated successfully: {}", filename);
        return new FileValidationResult(false, "File is safe.");
    }
}
