package com.aashdit.construction.utils;

import javax.crypto.Cipher;
import javax.crypto.spec.GCMParameterSpec;
import javax.crypto.spec.SecretKeySpec;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.security.GeneralSecurityException;
import java.security.SecureRandom;
import java.util.Base64;

import lombok.extern.slf4j.Slf4j;

/**
 * Utility class for AES-GCM encryption and decryption.
 *
 * AES/GCM/NoPadding is preferred over ECB for security. Provides authenticated
 * encryption (confidentiality + integrity).
 *
 * @author Somanath Singh
 * @since 18/08/2025
 */
@Slf4j
public final class EncryptionUtilGCM {

	private static final String ALGORITHM = "AES";
	private static final String TRANSFORMATION = "AES/GCM/NoPadding";

	// GCM recommended values
	private static final int GCM_TAG_LENGTH = 128; // bits
	private static final int GCM_IV_LENGTH = 12; // bytes
	
	private static final String SECRET = "MySecretKey12345";  
	private static final SecretKeySpec SECRET_KEY = new SecretKeySpec(SECRET.getBytes(StandardCharsets.UTF_8), ALGORITHM);

	private EncryptionUtilGCM() {
		// prevent instantiation
	}

	/**
	 * Encrypts plain text using AES/GCM.
	 *
	 * @param plainText the text to encrypt
	 * @return Base64 encoded string containing IV + cipher text
	 */
	public static String encrypt(String plainText) {
		try {
			if (plainText == null || plainText.isBlank()) {
				throw new EncryptionException("Plain text is null or empty", null);
			}

			byte[] iv = new byte[GCM_IV_LENGTH];
			new SecureRandom().nextBytes(iv);

			Cipher cipher = Cipher.getInstance(TRANSFORMATION);
			cipher.init(Cipher.ENCRYPT_MODE, SECRET_KEY, new GCMParameterSpec(GCM_TAG_LENGTH, iv));

			byte[] cipherText = cipher.doFinal(plainText.getBytes(StandardCharsets.UTF_8));

			ByteBuffer buffer = ByteBuffer.allocate(iv.length + cipherText.length);
			buffer.put(iv);
			buffer.put(cipherText);

			String encrypted = Base64.getUrlEncoder().encodeToString(buffer.array());
			log.debug("Encrypted string length: {}", plainText.length());
			return encrypted;
		} catch (GeneralSecurityException e) {
			log.error("Encryption failed for value: {}. Error: {}", plainText, e.getMessage());
			throw new EncryptionException("Failed to encrypt value", e);
		}
	}

	/**
	 * Decrypts AES/GCM encrypted text back to plain string.
	 *
	 * @param encryptedText Base64 encoded string containing IV + cipher text
	 * @return plain string
	 */
	public static String decryptToString(String encryptedText) {
		try {
			if (encryptedText == null || encryptedText.isBlank()) {
				throw new EncryptionException("Encrypted text is null or empty", null);
			}

			byte[] decoded = Base64.getUrlDecoder().decode(encryptedText);
			ByteBuffer buffer = ByteBuffer.wrap(decoded);

			byte[] iv = new byte[GCM_IV_LENGTH];
			buffer.get(iv);

			byte[] cipherText = new byte[buffer.remaining()];
			buffer.get(cipherText);

			Cipher cipher = Cipher.getInstance(TRANSFORMATION);
			cipher.init(Cipher.DECRYPT_MODE, SECRET_KEY, new GCMParameterSpec(GCM_TAG_LENGTH, iv));

			byte[] plainText = cipher.doFinal(cipherText);
			String decrypted = new String(plainText, StandardCharsets.UTF_8);

			log.debug("Decrypted string length: {}", decrypted.length());
			return decrypted;
		} catch (GeneralSecurityException e) {
			log.error("Decryption failed for value: {}. Error: {}", encryptedText, e.getMessage());
			throw new EncryptionException("Failed to decrypt value", e);
		}
	}

	/**
	 * Encrypts a Long ID to AES/GCM encrypted string.
	 *
	 * @param id Long value to encrypt
	 * @return encrypted string
	 */
	public static String encryptLong(Long id) {
		if (id == null) {
			throw new EncryptionException("ID is null", null);
		}
		return encrypt(String.valueOf(id));
	}

	/**
	 * Decrypts AES/GCM encrypted string back into a Long.
	 *
	 * @param encryptedText encrypted value
	 * @return Long
	 */
	public static Long decryptToLong(String encryptedText) {
		try {
			String decrypted = decryptToString(encryptedText);
			return Long.parseLong(decrypted);
		} catch (NumberFormatException e) {
			log.error("Failed to parse decrypted text to Long: {}", e.getMessage());
			throw new EncryptionException("Failed to decrypt to Long", e);
		}
	}

	/**
	 * Custom runtime exception for encryption/decryption errors.
	 */
	public static class EncryptionException extends RuntimeException {
		private static final long serialVersionUID = 1L;

		public EncryptionException(String message, Throwable cause) {
			super(message, cause);
		}
	}
}
